/* Automatically generated by
	SmartSyntaxPluginCodeGenerator * VMMaker-eem.727 uuid: ddd40ec5-cf16-45d0-876f-d465abbddd04
   from
	SnappyPlugin Snappy-Plugin-mu.32 uuid: 87c626d6-0e33-6947-8e9a-d027ee84d189
 */
static char __buildInfo[] = "SnappyPlugin Snappy-Plugin-mu.32 uuid: 87c626d6-0e33-6947-8e9a-d027ee84d189 " __DATE__ ;



#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif

#include "sqMemoryAccess.h"


#include <snappy-c.h> /* Snappy C API */


/*** Constants ***/
#define SnInvalidInput 2
#define SnOK 0
#define SnStFallbackFailed -1


/*** Function Prototypes ***/
static char* charPointerFor(sqInt obj);
static VirtualMachine * getInterpreter(void);
EXPORT(const char*) getModuleName(void);
static sqInt halt(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt msg(char *s);
static sqInt oopFromCBytessized(char*cBytes, sqInt bytesSize);
EXPORT(void) primitiveCompress(void);
EXPORT(void) primitiveCompressWithOffset(void);
EXPORT(void) primitiveCopyBytes(void);
EXPORT(void) primitiveMaxCompressedLength(void);
EXPORT(void) primitiveRawCompress(void);
EXPORT(void) primitiveRawUncompress(void);
EXPORT(void) primitiveRawUncompressedLength(void);
EXPORT(void) primitiveRawValidateCompressedBuffer(void);
EXPORT(void) primitiveUncompress(void);
EXPORT(void) primitiveUncompressedLength(void);
EXPORT(void) primitiveUncompressWithOffset(void);
EXPORT(void) primitiveValidateCompressedBuffer(void);
static void returnErrorInfoFor(sqInt statusCode);
static void returnIntegerFor(sqInt cInteger);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
EXPORT(sqInt) shutdownModule(void);
static void sqAssert(sqInt aBool);
static void * stackBytesValue(sqInt index);
static char* stackCharPointer(sqInt index);
static sqInt stackPositiveIntegerValue(sqInt index);


/*** Variables ***/

#ifdef SQUEAK_BUILTIN_PLUGIN
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"SnappyPlugin Snappy-Plugin-mu.32 (i)"
#else
	"SnappyPlugin Snappy-Plugin-mu.32 (e)"
#endif
;



/*	The stack object at 'index' should be an ExternalAddress; this function
	answers a pointer to the actual address (skip the object header).
 */

static char*
charPointerFor(sqInt obj)
{
	char* ptr;

	if (!(interpreterProxy->isBytes(obj))) {
		return null;
	}
	ptr = interpreterProxy->firstIndexableField(obj);
	return ptr;
}


/*	Note: This is coded so that plugins can be run from Squeak. */

static VirtualMachine *
getInterpreter(void)
{
	return interpreterProxy;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important!
 */

EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

static sqInt
halt(void)
{
	;
	return 0;
}

EXPORT(sqInt)
initialiseModule(void)
{
	return 1;
}

static sqInt
msg(char *s)
{
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}

static sqInt
oopFromCBytessized(char*cBytes, sqInt bytesSize)
{
	char*dstPtr;
	sqInt i;
	sqInt result;
	sqInt sz;

	if (cBytes == null) {
		return interpreterProxy->nilObject();
	}
	sz = bytesSize;
	result = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classByteArray(), sz);
	interpreterProxy->pushRemappableOop(result);
	dstPtr = interpreterProxy->firstIndexableField(result);
	for (i = 0; i <= (sz - 1); i += 1) {
		dstPtr[i] = (cBytes[i]);
	}
	return interpreterProxy->popRemappableOop();
}

EXPORT(void)
primitiveCompress(void)
{
	char* compressed;
	size_t compressedLength;
	const char*input;
	sqInt inputLength;
	sqInt inputObj;
	char* ptr;
	sqInt status;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		interpreterProxy->primitiveFail(); return;
	}
	inputObj = interpreterProxy->stackValue(0);
	/* begin charPointerFor: */
	if (!(interpreterProxy->isBytes(inputObj))) {
		input = ((char*) null);
		goto l1;
	}
	ptr = interpreterProxy->firstIndexableField(inputObj);
	input = ((char*) ptr);
l1:	/* end charPointerFor: */;
	if (!(input)) {
		interpreterProxy->primitiveFail(); return;
	}
	inputLength = interpreterProxy->byteSizeOf(inputObj);
	;
	compressedLength = snappy_max_compressed_length(inputLength);
	if (compressedLength < 1) {
		interpreterProxy->primitiveFail(); return;
	}
	compressed = malloc(compressedLength);
	if (!(compressed)) {
		interpreterProxy->primitiveFail(); return;
	}
	status = snappy_compress(input, inputLength, compressed, &compressedLength);
	if (!(status == 0)) {
		/* begin returnErrorInfoFor: */
		interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
		interpreterProxy->pushInteger(-status);
		return;
	}
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->push(oopFromCBytessized(compressed, compressedLength));
	free(compressed);
}

EXPORT(void)
primitiveCompressWithOffset(void)
{
	char* compressed;
	size_t compressedLength;
	const char*input;
	sqInt inputLength;
	sqInt inputObj;
	size_t inputOffset;
	sqInt num;
	char* ptr;
	sqInt status;

	if (!((interpreterProxy->methodArgumentCount()) == 2)) {
		interpreterProxy->primitiveFail(); return;
	}
	inputObj = interpreterProxy->stackValue(1);
	/* begin charPointerFor: */
	if (!(interpreterProxy->isBytes(inputObj))) {
		input = ((char*) null);
		goto l1;
	}
	ptr = interpreterProxy->firstIndexableField(inputObj);
	input = ((char*) ptr);
l1:	/* end charPointerFor: */;
	if (!(input)) {
		interpreterProxy->primitiveFail(); return;
	}
	/* begin stackPositiveIntegerValue: */
	num = interpreterProxy->stackValue(0);
	if ((interpreterProxy->isIntegerValue(num))
	 && (num < 0)) {
		inputOffset = ((sqInt) null);
		goto l2;
	}
	inputOffset = ((sqInt) (interpreterProxy->positive32BitValueOf(num)));
l2:	/* end stackPositiveIntegerValue: */;
	inputLength = interpreterProxy->byteSizeOf(interpreterProxy->stackValue(1));
	;
	compressedLength = snappy_max_compressed_length(inputLength);
	if (compressedLength < 1) {
		interpreterProxy->primitiveFail(); return;
	}
	compressed = malloc(compressedLength);
	if (!(compressed)) {
		interpreterProxy->primitiveFail(); return;
	}
	status = snappy_compress(input + inputOffset, inputLength, compressed, &compressedLength);
	if (!(status == 0)) {
		/* begin returnErrorInfoFor: */
		interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
		interpreterProxy->pushInteger(-status);
		return;
	}
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->push(oopFromCBytessized(compressed, compressedLength));
	free(compressed);
}

EXPORT(void)
primitiveCopyBytes(void)
{
	const char*input;
	size_t inputLength;
	sqInt inputObj;
	size_t inputOffset;
	sqInt num;
	sqInt num1;
	sqInt num2;
	sqInt obj;
	char*output;
	size_t outputOffset;
	char* ptr;
	char* ptr1;
	char* ret;

	if (!((interpreterProxy->methodArgumentCount()) == 5)) {
		interpreterProxy->primitiveFail(); return;
	}
	inputObj = interpreterProxy->stackValue(4);
	/* begin charPointerFor: */
	if (!(interpreterProxy->isBytes(inputObj))) {
		input = ((char*) null);
		goto l1;
	}
	ptr = interpreterProxy->firstIndexableField(inputObj);
	input = ((char*) ptr);
l1:	/* end charPointerFor: */;
	if (!(input)) {
		interpreterProxy->primitiveFail(); return;
	}
	/* begin stackPositiveIntegerValue: */
	num = interpreterProxy->stackValue(3);
	if ((interpreterProxy->isIntegerValue(num))
	 && (num < 0)) {
		inputOffset = ((sqInt) null);
		goto l2;
	}
	inputOffset = ((sqInt) (interpreterProxy->positive32BitValueOf(num)));
l2:	/* end stackPositiveIntegerValue: */;
	/* begin stackPositiveIntegerValue: */
	num1 = interpreterProxy->stackValue(2);
	if ((interpreterProxy->isIntegerValue(num1))
	 && (num1 < 0)) {
		inputLength = ((sqInt) null);
		goto l3;
	}
	inputLength = ((sqInt) (interpreterProxy->positive32BitValueOf(num1)));
l3:	/* end stackPositiveIntegerValue: */;
	/* begin stackCharPointer: */
	obj = interpreterProxy->stackObjectValue(1);
	if (!(interpreterProxy->isBytes(obj))) {
		output = null;
		goto l4;
	}
	ptr1 = interpreterProxy->firstIndexableField(obj);
	output = ptr1;
l4:	/* end stackCharPointer: */;
	/* begin stackPositiveIntegerValue: */
	num2 = interpreterProxy->stackValue(0);
	if ((interpreterProxy->isIntegerValue(num2))
	 && (num2 < 0)) {
		outputOffset = ((sqInt) null);
		goto l5;
	}
	outputOffset = ((sqInt) (interpreterProxy->positive32BitValueOf(num2)));
l5:	/* end stackPositiveIntegerValue: */;
	ret = memcpy(output + outputOffset, input + inputOffset, inputLength);
	if (ret == 0) {
		interpreterProxy->primitiveFail(); return;
	}
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->push(oopFromCBytessized(ret, inputLength));
}

EXPORT(void)
primitiveMaxCompressedLength(void)
{
	size_t destLength;
	sqInt num;
	size_t sourceLength;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		interpreterProxy->primitiveFail(); return;
	}
	/* begin stackPositiveIntegerValue: */
	num = interpreterProxy->stackValue(0);
	if ((interpreterProxy->isIntegerValue(num))
	 && (num < 0)) {
		sourceLength = ((sqInt) null);
		goto l1;
	}
	sourceLength = ((sqInt) (interpreterProxy->positive32BitValueOf(num)));
l1:	/* end stackPositiveIntegerValue: */;
	destLength = snappy_max_compressed_length(sourceLength);
	if (destLength < 1) {
		interpreterProxy->primitiveFail(); return;
	}
	/* begin returnIntegerFor: */
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	if (destLength <= 1073741823) {
		interpreterProxy->pushInteger(destLength);
	}
	else {
		interpreterProxy->push(interpreterProxy->positive32BitIntegerFor(destLength));
	}
}

EXPORT(void)
primitiveRawCompress(void)
{
	char*compressed;
	size_t compressedLength;
	sqInt compressedObj;
	const char*input;
	size_t inputLength;
	sqInt inputObj;
	size_t inputOffset;
	sqInt num;
	sqInt num1;
	sqInt num2;
	size_t outputOffset;
	char* ptr;
	char* ptr1;
	snappy_status status;

	if (!((interpreterProxy->methodArgumentCount()) == 5)) {
		interpreterProxy->primitiveFail(); return;
	}
	inputObj = interpreterProxy->stackValue(4);
	/* begin charPointerFor: */
	if (!(interpreterProxy->isBytes(inputObj))) {
		input = ((char*) null);
		goto l1;
	}
	ptr = interpreterProxy->firstIndexableField(inputObj);
	input = ((char*) ptr);
l1:	/* end charPointerFor: */;
	if (!(input)) {
		interpreterProxy->primitiveFail(); return;
	}
	/* begin stackPositiveIntegerValue: */
	num = interpreterProxy->stackValue(3);
	if ((interpreterProxy->isIntegerValue(num))
	 && (num < 0)) {
		inputOffset = ((sqInt) null);
		goto l3;
	}
	inputOffset = ((sqInt) (interpreterProxy->positive32BitValueOf(num)));
l3:	/* end stackPositiveIntegerValue: */;
	/* begin stackPositiveIntegerValue: */
	num1 = interpreterProxy->stackValue(2);
	if ((interpreterProxy->isIntegerValue(num1))
	 && (num1 < 0)) {
		inputLength = ((sqInt) null);
		goto l4;
	}
	inputLength = ((sqInt) (interpreterProxy->positive32BitValueOf(num1)));
l4:	/* end stackPositiveIntegerValue: */;
	compressedObj = interpreterProxy->stackValue(1);
	/* begin charPointerFor: */
	if (!(interpreterProxy->isBytes(compressedObj))) {
		compressed = null;
		goto l2;
	}
	ptr1 = interpreterProxy->firstIndexableField(compressedObj);
	compressed = ptr1;
l2:	/* end charPointerFor: */;
	if (!(compressed)) {
		interpreterProxy->primitiveFail(); return;
	}
	/* begin stackPositiveIntegerValue: */
	num2 = interpreterProxy->stackValue(0);
	if ((interpreterProxy->isIntegerValue(num2))
	 && (num2 < 0)) {
		outputOffset = ((sqInt) null);
		goto l5;
	}
	outputOffset = ((sqInt) (interpreterProxy->positive32BitValueOf(num2)));
l5:	/* end stackPositiveIntegerValue: */;
	compressedLength = interpreterProxy->byteSizeOf(compressedObj);
	status = snappy_compress(input + inputOffset, inputLength, compressed + outputOffset, &compressedLength);
	if (!(status == 0)) {
		/* begin returnErrorInfoFor: */
		interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
		interpreterProxy->pushInteger(-status);
		return;
	}
	/* begin returnIntegerFor: */
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	if (compressedLength <= 1073741823) {
		interpreterProxy->pushInteger(compressedLength);
	}
	else {
		interpreterProxy->push(interpreterProxy->positive32BitIntegerFor(compressedLength));
	}
}

EXPORT(void)
primitiveRawUncompress(void)
{
	const char*compressed;
	size_t compressedLength;
	sqInt compressedObj;
	size_t inputOffset;
	sqInt num;
	sqInt num1;
	sqInt num2;
	size_t outputOffset;
	char* ptr;
	char* ptr1;
	snappy_status status;
	char*uncompressed;
	size_t uncompressedLength;
	sqInt uncompressedObj;

	if (!((interpreterProxy->methodArgumentCount()) == 5)) {
		interpreterProxy->primitiveFail(); return;
	}
	compressedObj = interpreterProxy->stackValue(4);
	/* begin charPointerFor: */
	if (!(interpreterProxy->isBytes(compressedObj))) {
		compressed = ((char*) null);
		goto l1;
	}
	ptr = interpreterProxy->firstIndexableField(compressedObj);
	compressed = ((char*) ptr);
l1:	/* end charPointerFor: */;
	if (!(compressed)) {
		interpreterProxy->primitiveFail(); return;
	}
	/* begin stackPositiveIntegerValue: */
	num = interpreterProxy->stackValue(3);
	if ((interpreterProxy->isIntegerValue(num))
	 && (num < 0)) {
		inputOffset = ((sqInt) null);
		goto l3;
	}
	inputOffset = ((sqInt) (interpreterProxy->positive32BitValueOf(num)));
l3:	/* end stackPositiveIntegerValue: */;
	/* begin stackPositiveIntegerValue: */
	num1 = interpreterProxy->stackValue(2);
	if ((interpreterProxy->isIntegerValue(num1))
	 && (num1 < 0)) {
		compressedLength = ((sqInt) null);
		goto l4;
	}
	compressedLength = ((sqInt) (interpreterProxy->positive32BitValueOf(num1)));
l4:	/* end stackPositiveIntegerValue: */;
	uncompressedObj = interpreterProxy->stackValue(1);
	/* begin charPointerFor: */
	if (!(interpreterProxy->isBytes(uncompressedObj))) {
		uncompressed = null;
		goto l2;
	}
	ptr1 = interpreterProxy->firstIndexableField(uncompressedObj);
	uncompressed = ptr1;
l2:	/* end charPointerFor: */;
	if (!(uncompressed)) {
		interpreterProxy->primitiveFail(); return;
	}
	/* begin stackPositiveIntegerValue: */
	num2 = interpreterProxy->stackValue(0);
	if ((interpreterProxy->isIntegerValue(num2))
	 && (num2 < 0)) {
		outputOffset = ((sqInt) null);
		goto l5;
	}
	outputOffset = ((sqInt) (interpreterProxy->positive32BitValueOf(num2)));
l5:	/* end stackPositiveIntegerValue: */;
	uncompressedLength = interpreterProxy->byteSizeOf(uncompressedObj);
	status = snappy_uncompress(compressed + inputOffset, compressedLength, uncompressed + outputOffset, &uncompressedLength);
	if (!(status == 0)) {
		/* begin returnErrorInfoFor: */
		interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
		interpreterProxy->pushInteger(-status);
		return;
	}
	/* begin returnIntegerFor: */
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	if (uncompressedLength <= 1073741823) {
		interpreterProxy->pushInteger(uncompressedLength);
	}
	else {
		interpreterProxy->push(interpreterProxy->positive32BitIntegerFor(uncompressedLength));
	}
}

EXPORT(void)
primitiveRawUncompressedLength(void)
{
	const char*compressed;
	size_t compressedLength;
	sqInt compressedObj;
	sqInt num;
	sqInt num1;
	size_t offset;
	char* ptr;
	size_t result;
	snappy_status status;

	if (!((interpreterProxy->methodArgumentCount()) == 3)) {
		interpreterProxy->primitiveFail(); return;
	}
	compressedObj = interpreterProxy->stackValue(2);
	/* begin charPointerFor: */
	if (!(interpreterProxy->isBytes(compressedObj))) {
		compressed = ((char*) null);
		goto l1;
	}
	ptr = interpreterProxy->firstIndexableField(compressedObj);
	compressed = ((char*) ptr);
l1:	/* end charPointerFor: */;
	if (!(compressed)) {
		interpreterProxy->primitiveFail(); return;
	}
	/* begin stackPositiveIntegerValue: */
	num = interpreterProxy->stackValue(1);
	if ((interpreterProxy->isIntegerValue(num))
	 && (num < 0)) {
		offset = ((sqInt) null);
		goto l2;
	}
	offset = ((sqInt) (interpreterProxy->positive32BitValueOf(num)));
l2:	/* end stackPositiveIntegerValue: */;
	/* begin stackPositiveIntegerValue: */
	num1 = interpreterProxy->stackValue(0);
	if ((interpreterProxy->isIntegerValue(num1))
	 && (num1 < 0)) {
		compressedLength = ((sqInt) null);
		goto l3;
	}
	compressedLength = ((sqInt) (interpreterProxy->positive32BitValueOf(num1)));
l3:	/* end stackPositiveIntegerValue: */;
	status = snappy_uncompressed_length(compressed + offset, compressedLength, &result);
	if (status == SnOK) {
		/* begin returnIntegerFor: */
		interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
		if (result <= 1073741823) {
			interpreterProxy->pushInteger(result);
		}
		else {
			interpreterProxy->push(interpreterProxy->positive32BitIntegerFor(result));
		}
		return;
	}
	/* begin returnErrorInfoFor: */
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->pushInteger(-status);
}

EXPORT(void)
primitiveRawValidateCompressedBuffer(void)
{
	const char*compressed;
	size_t compressedLength;
	sqInt compressedObj;
	sqInt num;
	sqInt num1;
	size_t offset;
	char* ptr;
	snappy_status status;

	if (!((interpreterProxy->methodArgumentCount()) == 3)) {
		interpreterProxy->primitiveFail(); return;
	}
	compressedObj = interpreterProxy->stackValue(2);
	/* begin charPointerFor: */
	if (!(interpreterProxy->isBytes(compressedObj))) {
		compressed = ((char*) null);
		goto l1;
	}
	ptr = interpreterProxy->firstIndexableField(compressedObj);
	compressed = ((char*) ptr);
l1:	/* end charPointerFor: */;
	if (!(compressed)) {
		interpreterProxy->primitiveFail(); return;
	}
	/* begin stackPositiveIntegerValue: */
	num = interpreterProxy->stackValue(1);
	if ((interpreterProxy->isIntegerValue(num))
	 && (num < 0)) {
		offset = ((sqInt) null);
		goto l2;
	}
	offset = ((sqInt) (interpreterProxy->positive32BitValueOf(num)));
l2:	/* end stackPositiveIntegerValue: */;
	/* begin stackPositiveIntegerValue: */
	num1 = interpreterProxy->stackValue(0);
	if ((interpreterProxy->isIntegerValue(num1))
	 && (num1 < 0)) {
		compressedLength = ((sqInt) null);
		goto l3;
	}
	compressedLength = ((sqInt) (interpreterProxy->positive32BitValueOf(num1)));
l3:	/* end stackPositiveIntegerValue: */;
	status = snappy_validate_compressed_buffer(compressed + offset, compressedLength);
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->pushInteger(status);
}

EXPORT(void)
primitiveUncompress(void)
{
	const char*compressed;
	size_t compressedLength;
	sqInt compressedObj;
	char* ptr;
	snappy_status status;
	char* uncompressed;
	size_t uncompressedLength;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		interpreterProxy->primitiveFail(); return;
	}
	compressedObj = interpreterProxy->stackValue(0);
	/* begin charPointerFor: */
	if (!(interpreterProxy->isBytes(compressedObj))) {
		compressed = ((char*) null);
		goto l1;
	}
	ptr = interpreterProxy->firstIndexableField(compressedObj);
	compressed = ((char*) ptr);
l1:	/* end charPointerFor: */;
	if (!(compressed)) {
		interpreterProxy->primitiveFail(); return;
	}
	compressedLength = interpreterProxy->byteSizeOf(compressedObj);
	status = snappy_uncompressed_length(compressed, compressedLength, &uncompressedLength);
	if (!(status == 0)) {
		interpreterProxy->primitiveFailFor(status); return;
	}
	uncompressed = malloc(uncompressedLength);
	status = snappy_uncompress(compressed, compressedLength, uncompressed, &uncompressedLength);
	if (!(status == 0)) {
		/* begin returnErrorInfoFor: */
		interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
		interpreterProxy->pushInteger(-status);
		return;
	}
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->push(oopFromCBytessized(uncompressed, uncompressedLength));
	free(uncompressed);
}

EXPORT(void)
primitiveUncompressedLength(void)
{
	const char*compressed;
	size_t compressedLength;
	sqInt compressedObj;
	char* ptr;
	size_t result;
	snappy_status status;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		interpreterProxy->primitiveFail(); return;
	}
	compressedObj = interpreterProxy->stackValue(0);
	/* begin charPointerFor: */
	if (!(interpreterProxy->isBytes(compressedObj))) {
		compressed = ((char*) null);
		goto l1;
	}
	ptr = interpreterProxy->firstIndexableField(compressedObj);
	compressed = ((char*) ptr);
l1:	/* end charPointerFor: */;
	if (!(compressed)) {
		interpreterProxy->primitiveFail(); return;
	}
	compressedLength = interpreterProxy->byteSizeOf(compressedObj);
	status = snappy_uncompressed_length(compressed, compressedLength, &result);
	if (status == SnOK) {
		/* begin returnIntegerFor: */
		interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
		if (result <= 1073741823) {
			interpreterProxy->pushInteger(result);
		}
		else {
			interpreterProxy->push(interpreterProxy->positive32BitIntegerFor(result));
		}
		return;
	}
	/* begin returnErrorInfoFor: */
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->pushInteger(-status);
}

EXPORT(void)
primitiveUncompressWithOffset(void)
{
	const char*compressed;
	size_t compressedLength;
	sqInt compressedObj;
	size_t inputOffset;
	sqInt num;
	char* ptr;
	snappy_status status;
	char* uncompressed;
	size_t uncompressedLength;

	if (!((interpreterProxy->methodArgumentCount()) == 2)) {
		interpreterProxy->primitiveFail(); return;
	}
	compressedObj = interpreterProxy->stackValue(1);
	/* begin charPointerFor: */
	if (!(interpreterProxy->isBytes(compressedObj))) {
		compressed = ((char*) null);
		goto l1;
	}
	ptr = interpreterProxy->firstIndexableField(compressedObj);
	compressed = ((char*) ptr);
l1:	/* end charPointerFor: */;
	if (!(compressed)) {
		interpreterProxy->primitiveFail(); return;
	}
	/* begin stackPositiveIntegerValue: */
	num = interpreterProxy->stackValue(0);
	if ((interpreterProxy->isIntegerValue(num))
	 && (num < 0)) {
		inputOffset = ((sqInt) null);
		goto l2;
	}
	inputOffset = ((sqInt) (interpreterProxy->positive32BitValueOf(num)));
l2:	/* end stackPositiveIntegerValue: */;
	compressedLength = interpreterProxy->byteSizeOf(compressedObj);
	status = snappy_uncompressed_length(compressed + inputOffset, compressedLength, &uncompressedLength);
	if (!(status == 0)) {
		interpreterProxy->primitiveFailFor(status); return;
	}
	uncompressed = malloc(uncompressedLength);
	status = snappy_uncompress(compressed + inputOffset, compressedLength, uncompressed, &uncompressedLength);
	if (!(status == 0)) {
		/* begin returnErrorInfoFor: */
		interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
		interpreterProxy->pushInteger(-status);
		return;
	}
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->push(oopFromCBytessized(uncompressed, uncompressedLength));
	free(uncompressed);
}

EXPORT(void)
primitiveValidateCompressedBuffer(void)
{
	const char*compressed;
	size_t compressedLength;
	sqInt compressedObj;
	char* ptr;
	snappy_status status;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		interpreterProxy->primitiveFail(); return;
	}
	compressedObj = interpreterProxy->stackValue(0);
	/* begin charPointerFor: */
	if (!(interpreterProxy->isBytes(compressedObj))) {
		compressed = ((char*) null);
		goto l1;
	}
	ptr = interpreterProxy->firstIndexableField(compressedObj);
	compressed = ((char*) ptr);
l1:	/* end charPointerFor: */;
	if (!(compressed)) {
		interpreterProxy->primitiveFail(); return;
	}
	compressedLength = interpreterProxy->byteSizeOf(compressedObj);
	status = snappy_validate_compressed_buffer(compressed, compressedLength);
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->pushInteger(status);
}


/*	use nagative value for indicating error info */

static void
returnErrorInfoFor(sqInt statusCode)
{
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	interpreterProxy->pushInteger(-statusCode);
}

static void
returnIntegerFor(sqInt cInteger)
{
	interpreterProxy->pop((interpreterProxy->methodArgumentCount()) + 1);
	if (cInteger <= 1073741823) {
		interpreterProxy->pushInteger(cInteger);
	}
	else {
		interpreterProxy->push(interpreterProxy->positive32BitIntegerFor(cInteger));
	}
}


/*	Note: This is coded so that is can be run from Squeak. */

EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter)
{
	sqInt ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;
	if (ok == 0) {
		return 0;
	}
	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;
	return ok;
}

EXPORT(sqInt)
shutdownModule(void)
{
	return 1;
}

static void
sqAssert(sqInt aBool)
{
	/* missing DebugCode */;
}

static void *
stackBytesValue(sqInt index)
{
	char*dstPtr;
	sqInt i;
	sqInt obj;
	char*srcPtr;
	sqInt sz;

	obj = interpreterProxy->stackValue(index);
	if (!(interpreterProxy->isBytes(obj))) {
		interpreterProxy->primitiveFail();
		return null;
	}
	sz = interpreterProxy->byteSizeOf(obj);
	dstPtr = malloc(sz);
	if (!(dstPtr)) {
		interpreterProxy->primitiveFail();
		return null;
	}
	srcPtr = interpreterProxy->firstIndexableField(obj);
	for (i = 0; i <= sz; i += 1) {
		dstPtr[i] = (srcPtr[i]);
	}
	return dstPtr;
}


/*	The stack object at 'index' should be an ExternalAddress; this function
	answers a pointer to the actual address (skip the object header).
 */

static char*
stackCharPointer(sqInt index)
{
	sqInt obj;
	char* ptr;

	obj = interpreterProxy->stackObjectValue(index);
	if (!(interpreterProxy->isBytes(obj))) {
		return null;
	}
	ptr = interpreterProxy->firstIndexableField(obj);
	return ptr;
}

static sqInt
stackPositiveIntegerValue(sqInt index)
{
	sqInt num;

	num = interpreterProxy->stackValue(index);
	if ((interpreterProxy->isIntegerValue(num))
	 && (num < 0)) {
		return null;
	}
	return interpreterProxy->positive32BitValueOf(num);
}


#ifdef SQUEAK_BUILTIN_PLUGIN

void* SnappyPlugin_exports[][3] = {
	{"SnappyPlugin", "getModuleName", (void*)getModuleName},
	{"SnappyPlugin", "initialiseModule", (void*)initialiseModule},
	{"SnappyPlugin", "primitiveCompress", (void*)primitiveCompress},
	{"SnappyPlugin", "primitiveCompressWithOffset", (void*)primitiveCompressWithOffset},
	{"SnappyPlugin", "primitiveCopyBytes", (void*)primitiveCopyBytes},
	{"SnappyPlugin", "primitiveMaxCompressedLength", (void*)primitiveMaxCompressedLength},
	{"SnappyPlugin", "primitiveRawCompress", (void*)primitiveRawCompress},
	{"SnappyPlugin", "primitiveRawUncompress", (void*)primitiveRawUncompress},
	{"SnappyPlugin", "primitiveRawUncompressedLength", (void*)primitiveRawUncompressedLength},
	{"SnappyPlugin", "primitiveRawValidateCompressedBuffer", (void*)primitiveRawValidateCompressedBuffer},
	{"SnappyPlugin", "primitiveUncompress", (void*)primitiveUncompress},
	{"SnappyPlugin", "primitiveUncompressedLength", (void*)primitiveUncompressedLength},
	{"SnappyPlugin", "primitiveUncompressWithOffset", (void*)primitiveUncompressWithOffset},
	{"SnappyPlugin", "primitiveValidateCompressedBuffer", (void*)primitiveValidateCompressedBuffer},
	{"SnappyPlugin", "setInterpreter", (void*)setInterpreter},
	{"SnappyPlugin", "shutdownModule", (void*)shutdownModule},
	{NULL, NULL, NULL}
};

#endif /* ifdef SQ_BUILTIN_PLUGIN */
